---
layout: post
title: 이벤트 루프
date: 2024-07-20 21:10 +0900
description: 이벤트 루프
image: ../assets/img/hyun80.jpg
category: ETC
tags: 이벤트 루프
published: true
sitemap: true
---


# 이벤트 루프 (Event Loop) 설명

이벤트 루프는 JavaScript와 같은 비동기 언어에서 중요한 역할을 합니다. 이벤트 루프는 단일 스레드에서 비동기 작업을 관리하고, 블로킹 없이 비동기 콜백을 처리하는 메커니즘입니다.

## 1. 이벤트 루프의 동작 원리

이벤트 루프는 기본적으로 다음과 같은 과정을 반복합니다:
1. **호출 스택(Call Stack) 확인**: 호출 스택은 현재 실행 중인 함수가 저장되는 자료 구조입니다. 자바스크립트 엔진은 호출 스택의 최상단에서 함수 실행을 시작합니다.
2. **태스크 큐(Task Queue) 확인**: 태스크 큐는 비동기 작업의 콜백 함수들이 대기하는 큐입니다. 이벤트 루프는 호출 스택이 비어 있을 때 태스크 큐에서 대기 중인 콜백 함수를 호출 스택으로 옮겨 실행합니다.

## 2. 주요 개념

### 호출 스택 (Call Stack)
호출 스택은 자바스크립트 엔진이 함수 호출을 관리하는 스택 자료 구조입니다. 함수가 호출되면 스택의 맨 위에 추가되고, 함수가 종료되면 스택에서 제거됩니다.

### 태스크 큐 (Task Queue)
태스크 큐는 비동기 작업의 콜백 함수들이 대기하는 큐입니다. 비동기 작업이 완료되면 해당 콜백 함수가 태스크 큐에 추가됩니다. 이벤트 루프는 호출 스택이 비어 있을 때 태스크 큐에서 콜백 함수를 가져와 실행합니다.

### 마이크로태스크 큐 (Microtask Queue)
마이크로태스크 큐는 프로미스의 `then`이나 `catch`, `finally`와 같은 마이크로태스크들이 대기하는 큐입니다. 마이크로태스크 큐는 태스크 큐보다 높은 우선순위를 가집니다. 이벤트 루프는 호출 스택이 비어 있을 때마다 마이크로태스크 큐를 먼저 처리합니다.

## 3. 이벤트 루프의 동작 예시

다음은 이벤트 루프가 어떻게 동작하는지를 보여주는 예시입니다:
```javascript
console.log('Start');

setTimeout(() => {
  console.log('Timeout');
}, 0);

Promise.resolve()
  .then(() => {
    console.log('Promise');
  });

console.log('End');
```

### 실행 순서 설명
1. `console.log('Start')`가 호출 스택에 추가되어 실행됩니다.
2. `setTimeout` 함수가 호출되고, 콜백 함수가 태스크 큐에 추가됩니다.
3. `Promise.resolve().then`이 호출되고, 콜백 함수가 마이크로태스크 큐에 추가됩니다.
4. `console.log('End')`가 호출 스택에 추가되어 실행됩니다.
5. 호출 스택이 비어 있고, 마이크로태스크 큐에 대기 중인 `Promise` 콜백이 호출 스택에 추가되어 실행됩니다.
6. 마이크로태스크 큐가 비어 있고, 태스크 큐에 대기 중인 `setTimeout` 콜백이 호출 스택에 추가되어 실행됩니다.

### 출력 결과
```
Start
End
Promise
Timeout
```

## 4. 이벤트 루프의 중요성

이벤트 루프는 비동기 작업을 효율적으로 관리하여 자바스크립트가 단일 스레드에서 비동기 작업을 처리할 수 있도록 합니다. 이를 통해 사용자 인터페이스가 블로킹되지 않고, 원활한 사용자 경험을 제공할 수 있습니다.

## 5. 참고 자료
- [MDN Web Docs: Event Loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop)
- [Node.js 공식 문서: 이벤트 루프](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/)

이벤트 루프는 자바스크립트의 핵심 개념 중 하나이며, 이를 이해함으로써 비동기 프로그래밍을 효과적으로 수행할 수 있습니다.
